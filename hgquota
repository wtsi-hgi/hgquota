#!/usr/bin/env perl

################################################################################
# Copyright (c) 2013, 2015 Genome Research Ltd. 
# 
# Author: Joshua C. Randall <jcrandall@alum.mit.edu>
# 
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU Affero General Public License as published by the Free 
# Software Foundation; either version 3 of the License, or (at your option) any 
# later version. 
# 
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more 
# details. 
# 
# You should have received a copy of the GNU Affero General Public License 
# along with this program. If not, see <http://www.gnu.org/licenses/>. 
################################################################################

use File::stat qw(stat);
use Sys::Filesystem::MountPoint qw(path_to_mount_point);
use Filesys::Df qw(df);
use LWP::Simple qw(get);
use HTML::TableExtract;

my $LOP_CMD="/software/hgi/pkglocal/lustre_operator-git-602b61d/bin/lustre_operator /usr/bin/lfs";
my $NFS_HG_URL="http://sandb.internal.sanger.ac.uk/humgen-quota.html";

# decimal SI unit labels from bytes to yottabytes
my $DECIMAL_UNIT_LABELS = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];

my $DEBUG=0;

my $dir = shift || ".";

my $st = stat($dir) or die "No such directory $dir: $!\n";
my ($group, undef) = getgrgid($st->gid);
print STDERR "Have group ${group}\n" if($DEBUG>0);

my $username = getpwuid($<) or die "Could not ascertain username for uid $<!";
print STDERR "Have username ${username}\n" if($DEBUG>0);

my $mount_point = path_to_mount_point($dir) or die "Could not determine mount point for $dir: $Sys::Filesystem::MountPoint::errstr\n";
print STDERR "Have mount point ${mount_point}\n" if($DEBUG>0);

sub lustre_get_group_size_remaining {
    my $mount_point = shift;
    my $group = shift;
    
    my $lop_group_output = `${LOP_CMD} ${mount_point} getquota -g ${group} -s GiB -f dumper` or die "Error getting quota for group ${group} on ${mount_point} - are you in group ${group}?\n";
    my $lop_group = eval ${lop_group_output};
    if ( exists($lop_group->{group}) &&
	 exists($lop_group->{group}->{${group}}) ) {
	my $size_remaining = $lop_group->{group}->{${group}}->{'size-remaining'};
	$size_remaining =~ s/[[:space:]]*GiB$//;
	print STDERR "${group} has ${size_remaining} GiB on ${mount_point}\n" if($DEBUG>0);
	return $size_remaining;
    } else {
	die "Could not parse output from lustre_operator: $lop_group_output\n";
    }
}

sub lustre_get_user_size_remaining {
    my $mount_point = shift;
    my $user = shift;
    
    my $lop_user_output = `${LOP_CMD} ${mount_point} getquota -u ${user} -s GiB -f dumper` or die "Error getting quota for user ${user} on ${mount_point}\n";
    my $lop_user = eval ${lop_user_output};
    if ( exists($lop_user->{user}) &&
	 exists($lop_user->{user}->{${user}}) ) {
	my $size_remaining = $lop_user->{user}->{${user}}->{'size-remaining'};
	$size_remaining =~ s/[[:space:]]*GiB$//;
	print STDERR "${user} has ${size_remaining} GiB on ${mount_point}\n" if($DEBUG>0);
	return $size_remaining;
    } else {
	die "Could not parse output from lustre_operator: $lop_user_output\n";
    }
}

sub bytes_to_gib {
    my $bytes = shift;
    return $bytes / (1024 ** 3);
}

sub lustre_get_size_available {
    my $mount_point = shift;
    my $df = df($mount_point, 1) or die "could not df ${mount_point}\n";
    my $bytes_avail = $df->{'bavail'} or die "could not get available bytes for ${mount_point}\n";
    my $gib_avail = bytes_to_gib($bytes_avail);
    print "filesystem mounted at ${mount_point} has $gib_avail GiB available\n" if($DEBUG>0);
    return $gib_avail;
}

sub lustre_get_available_quota {
    my $mount_point = shift;
    my $username = shift;
    my $group = shift;

    my $group_remaining = lustre_get_group_size_remaining($mount_point, $group);
    my $user_remaining = lustre_get_user_size_remaining($mount_point, $username);
    my $disk_avail = lustre_get_size_available($mount_point);

    my $available_quota = $disk_avail; 

    if (! ($group_remaining =~ m/unlimited/)) {
	$available_quota = $group_remaining;
    }
    if (! ($user_remaining =~ m/unlimited/)) {
	if ($user_remaining < $available_quota) {
	    $available_quota = $user_remaining;
	}
    }
    
    return $available_quota;
}

#################################################################################
# size_formatted_to_bytes - convert from formatted size units to bytes
#
# Inputs
#    1: formatted string with value and units (e.g. "1.5TiB")
# Returns
#    bytes
#################################################################################
sub size_formatted_to_bytes {
    my $formatted = shift;
    
    $formatted =~ m/^([0-9]+([.][0-9]+)?)[[:space:]]*((B|KiB|MiB|GiB|TiB|PiB|EiB|ZiB|YiB|kB|MB|GB|TB|PB|EB|ZB|YB){0,1})$/ or error_exit("convert_to_bytes: malformatted string [$formatted]");
    
    my $value = $1;
    my $units = $3 || "B";
    
    # fixed unit specification requiring conversion
    for (my $i=0; $i<@{$DECIMAL_UNIT_LABELS}; $i++) {
        if ($DECIMAL_UNIT_LABELS->[$i] eq $units) {
            return sprintf("%d", ($value * 1024 * (1000 ** ($i-1))));
        }
    }
    die "could not convert size $formatted to bytes\n";
}

sub humgen_nfs_get_remaining {
    my $mount_point = shift;
    my $group = shift;
    
    $content = get($NFS_HG_URL) or die "Couldn't retrieve NFS quota information from $NFS_HG_URL!\n";

    my $mount_point_vol = $mount_point;
    $mount_point_vol =~ s/\/nfs\///;
    
    my $te = HTML::TableExtract->new( headers => [qw(Volume ID Used Limit)] );
    $te->parse($content);
    foreach $row ($te->rows) {
	my ($vol, $id, $used, $limit) = @$row;
	if ($vol eq $mount_point_vol) {	
	    if ($id eq $group) {
		print STDERR "have used $used of limit $limit for group $group on ${mount_point}\n" if($DEBUG>0);
		my $limit_bytes = size_formatted_to_bytes($limit);
		my $used_bytes = size_formatted_to_bytes($used);
		my $remaining_bytes = $limit_bytes - $used_bytes;
		return bytes_to_gib($remaining_bytes);
	    }
	}
    }
}


my $available_quota_gib = 0;
if ($mount_point =~ m/^\/lustre\/scratch[[:digit:]]+$/) {
    print STDERR "Have a Lustre filesystem mounted at $mount_point\n" if($DEBUG>0);
    $available_quota_gib = lustre_get_available_quota($mount_point, $username, $group); 
} elsif ($mount_point =~ m/^\/nfs\/humgen/) {
    print STDERR "Have a humgen NFS filesystem mounted at $mount_point\n" if($DEBUG>0);
    $available_quota_gib = humgen_nfs_get_remaining($mount_point, $group);
} else {
    die "Mount point $mount_point is not a supported device.\n";
}

print "available quota for ${username}:${group} on ${mount_point} is ${available_quota_gib} GiB\n";

